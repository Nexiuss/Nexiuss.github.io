<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
            --font-size: 1.1rem;
        }
    </style>

    
    
    
    
    
    

    
    <title>闭包</title>
    <meta name="description" content="A blog post">
    <meta name="keywords" content='blog, gokarna, hugo'>

    <meta property="og:url" content="https://nexiuss.github.io/posts/%E9%97%AD%E5%8C%85/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="闭包">
    <meta property="og:description" content="A blog post">
    <meta property="og:image" content="https://nexiuss.github.io/images/20251204130608.png">
    <meta property="og:image:secure_url" content="https://nexiuss.github.io/images/20251204130608.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="闭包">
    <meta name="twitter:description" content="A blog post">
    <meta property="twitter:domain" content="https://nexiuss.github.io/posts/%E9%97%AD%E5%8C%85/">
    <meta property="twitter:url" content="https://nexiuss.github.io/posts/%E9%97%AD%E5%8C%85/">
    <meta name="twitter:image" content="https://nexiuss.github.io/images/20251204130608.png">

    
    <link rel="canonical" href="https://nexiuss.github.io/posts/%E9%97%AD%E5%8C%85/">

    
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">

    
    <script src="/js/bundle.min.a036ebe92c17ea3f0c07761c2135b82bec6f37c8efb7f49ddad1f28c22fc4769.js" integrity="sha256-oDbr6SwX6j8MB3YcITW4K&#43;xvN8jvt/Sd2tHyjCL8R2k="></script>

    
    
        <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
      });
    </script>
  
    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        
        <div class="avatar">
            <a href="https://nexiuss.github.io/">
                <img src='/images/logo.jpg' alt="avatar">
            </a>
        </div>
        

        <div class="nav-title">
            <a class="nav-brand" href="https://nexiuss.github.io/">Nexius</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://nexiuss.github.io/" aria-label="" ><span data-feather='home'></span> 首页 </a>
            </div>
            
            <div class="nav-link">
                <a href="https://nexiuss.github.io/posts/" aria-label="" ><span data-feather='book'></span> 文章 </a>
            </div>
            
            <div class="nav-link">
                <a href="https://nexiuss.github.io/projects/" aria-label="" ><span data-feather='code'></span> 项目 </a>
            </div>
            
            <div class="nav-link">
                <a href="https://nexiuss.github.io/tags/" aria-label="" ><span data-feather='tag'></span> 标签 </a>
            </div>
            
            <div class="nav-link">
                <a href="https://github.com/nexiuss" aria-label="github" ><span data-feather='github'></span>  </a>
            </div>
            
            <div class="nav-link">
                <a href="https://github.com/nexiuss" aria-label="buymeacoffee" ><span data-feather='coffee'></span>  </a>
            </div>
            
            <div class="nav-link">
                <a href="https://nexiuss.github.io/index.xml" aria-label="rss" ><span data-feather='rss'></span>  </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                <a aria-hidden="true" role="switch">
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a aria-checked="false" aria-labelledby="hamburger-menu-toggle" id="hamburger-menu-toggle-target" role="switch">
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://nexiuss.github.io/" ><span data-feather='home'></span> 首页 </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://nexiuss.github.io/posts/" ><span data-feather='book'></span> 文章 </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://nexiuss.github.io/projects/" ><span data-feather='code'></span> 项目 </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://nexiuss.github.io/tags/" ><span data-feather='tag'></span> 标签 </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://github.com/nexiuss" ><span data-feather='github'></span>  </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://github.com/nexiuss" ><span data-feather='coffee'></span>  </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://nexiuss.github.io/index.xml" ><span data-feather='rss'></span>  </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a role="switch">
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>闭包</h1>

        

        
	
	
	
	
        

	

	

	
          <small role="doc-subtitle">A blog post</small>
	

	
          <p class="post-date">
              

              December 4, 2025

              
          </p>
	

        <ul class="post-tags">
          
           
             <li class="post-tag"><a href="https://nexiuss.github.io/tags/blog">blog</a></li>
           
         
        </ul>
    </div>

    <div class="post-content">
        <h1 id="闭包javascript-核心特性深度解析">闭包：JavaScript 核心特性深度解析</h1>
<p>在 JavaScript 中，闭包是一个贯穿初级到高级开发的核心概念，它不仅是语言设计的精妙之处，也是实际开发中解决特定问题的重要工具。理解闭包的本质、原理和应用场景，能帮助开发者写出更优雅、更安全的代码。</p>
<h2 id="一什么是闭包">一、什么是闭包</h2>
<h3 id="1-核心定义">1. 核心定义</h3>
<p><em>闭包（Closure）</em> 是 JavaScript 函数的核心特性：<strong>当一个函数（内部函数）被定义在另一个函数（外部函数）的作用域内，并且内部函数被外部引用时，内部函数会保留对外部函数作用域（词法环境）的访问权限，即使外部函数已经执行完毕、其执行上下文已从调用栈中移除</strong>。</p>
<p>简单来说，闭包的核心是「函数 + 函数定义时的词法环境」，它让函数突破了&quot;调用时只能访问自身作用域和全局作用域&quot;的限制，实现了对外部函数局部变量的持久访问。</p>
<h3 id="2-闭包的形成条件">2. 闭包的形成条件</h3>
<p>闭包的形成必须同时满足以下三个条件，缺一不可：</p>
<ol>
<li><strong>嵌套函数结构</strong>：存在内部函数嵌套在外部函数中；</li>
<li><strong>作用域访问</strong>：内部函数引用了外部函数的局部变量（或参数）；</li>
<li><strong>外部引用</strong>：外部函数执行后，其返回值（或其他方式）将内部函数暴露到外部作用域，使得内部函数能被外部调用。</li>
</ol>
<h3 id="3-闭包的本质原理">3. 闭包的本质原理</h3>
<p>JavaScript 中函数的作用域是在<strong>定义时确定</strong>的（词法作用域），而非调用时。当外部函数执行时，会创建一个执行上下文，包含局部变量、参数、作用域链等信息。正常情况下，外部函数执行完毕后，其执行上下文会被垃圾回收机制回收。</p>
<p>但如果内部函数被外部引用（如作为返回值返回），由于内部函数的作用域链中包含了外部函数的词法环境，外部函数的局部变量会被内部函数&quot;引用持有&quot;，导致垃圾回收机制无法回收这部分内存，从而使内部函数在后续调用时仍能访问这些变量。</p>
<p><strong>示例：闭包的本质验证</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">outerFunc</span>(<span style="color:#a6e22e">name</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 外部函数局部变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">message</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">`Hello, </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">name</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 内部函数：引用外部函数变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">innerFunc</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">message</span>); <span style="color:#75715e">// 访问 outerFunc 的局部变量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 暴露内部函数到外部
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">innerFunc</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 外部函数执行完毕后，内部函数被外部引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sayHello</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">outerFunc</span>(<span style="color:#e6db74">&#34;闭包&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sayHello</span>(); <span style="color:#75715e">// 输出：Hello, 闭包（此时 outerFunc 已执行完毕，但 message 仍可访问）
</span></span></span></code></pre></div><h2 id="二闭包的特点与优缺点">二、闭包的特点与优缺点</h2>
<h3 id="1-核心特点">1. 核心特点</h3>
<p>基于闭包的原理，其具有以下三个关键特点：</p>
<ol>
<li><strong>外部访问内部变量</strong>：突破作用域限制，让外部代码间接访问函数内部的局部变量；</li>
<li><strong>变量持久化</strong>：外部函数的局部变量不会随函数执行完毕而销毁，会常驻内存直到内部函数被销毁；</li>
<li><strong>隔离作用域</strong>：创建独立的私有作用域，避免变量污染全局或其他作用域。</li>
</ol>
<h3 id="2-闭包的优势">2. 闭包的优势</h3>
<ol>
<li><strong>创建私有变量与方法</strong>：实现数据封装，避免全局变量污染。例如模拟类的私有成员，仅通过暴露的接口访问数据；</li>
<li><strong>延伸变量作用域</strong>：让局部变量在函数执行后仍能被使用，适用于需要&quot;记忆&quot;状态的场景（如计数器、缓存）；</li>
<li><strong>模块化开发</strong>：早期 JavaScript 没有模块化机制时，闭包是实现模块化的核心方案（如 IIFE 模式），隔离不同模块的变量冲突；</li>
<li><strong>回调函数场景适配</strong>：在定时器、事件监听、Promise 等异步回调中，闭包能保留回调执行所需的上下文环境。</li>
</ol>
<h3 id="3-闭包的潜在问题">3. 闭包的潜在问题</h3>
<ol>
<li><strong>内存占用</strong>：闭包会使外部函数的变量常驻内存，若大量创建闭包且未及时释放，可能导致内存泄漏；</li>
<li><strong>性能损耗</strong>：闭包的作用域链查找比普通函数更长，频繁调用可能带来轻微的性能开销；</li>
<li><strong>调试难度增加</strong>：闭包的变量生命周期复杂，若逻辑设计不当，可能导致变量状态混乱，难以调试。</li>
</ol>
<h2 id="三闭包的典型使用场景">三、闭包的典型使用场景</h2>
<p>闭包在实际开发中应用广泛，以下是最常见的场景及实践示例：</p>
<h3 id="1-返回值模式最常用">1. 返回值模式（最常用）</h3>
<p>通过外部函数返回内部函数，间接访问内部变量，实现数据封装。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 示例：实现一个计数器（变量 count 私有，仅通过暴露的方法修改）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createCounter</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// 私有变量，外部无法直接访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 返回对象，暴露操作接口
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">increment</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">count</span><span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">decrement</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">count</span><span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">getCount</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">count</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">counter</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">createCounter</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">increment</span>()); <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">increment</span>()); <span style="color:#75715e">// 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">decrement</span>()); <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">getCount</span>());  <span style="color:#75715e">// 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">counter</span>.<span style="color:#a6e22e">count</span>);       <span style="color:#75715e">// undefined（无法直接访问私有变量）
</span></span></span></code></pre></div><h3 id="2-回调函数与异步场景">2. 回调函数与异步场景</h3>
<p>在异步操作（定时器、事件监听、AJAX）中，闭包保留回调执行所需的上下文。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 示例1：定时器中的闭包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 利用立即执行函数（IIFE）创建闭包，保存每次循环的 i 值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  (<span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">index</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">index</span>); <span style="color:#75715e">// 输出：0、1、2（若不用闭包，会输出 3、3、3）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }, <span style="color:#ae81ff">1000</span> <span style="color:#f92672">*</span> (<span style="color:#a6e22e">index</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>  })(<span style="color:#a6e22e">i</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 示例2：事件监听中的闭包
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">bindEvents</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">btnText</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;点击触发&#34;</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;btn&#34;</span>).<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;click&#34;</span>, <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">btnText</span>); <span style="color:#75715e">// 闭包保留 btnText 变量，即使 bindEvents 已执行完毕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  });
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">bindEvents</span>();
</span></span></code></pre></div><h3 id="3-函数柯里化currying">3. 函数柯里化（Currying）</h3>
<p>柯里化是将多参数函数转化为单参数函数的过程，闭包是实现柯里化的核心。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 示例：实现加法函数的柯里化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">a</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 闭包保留第一个参数 a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">b</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 访问外部函数的 a，接收第二个参数 b
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">add5</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">5</span>); <span style="color:#75715e">// 保留 a = 5
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">add5</span>(<span style="color:#ae81ff">3</span>)); <span style="color:#75715e">// 8（5 + 3）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">add5</span>(<span style="color:#ae81ff">10</span>)); <span style="color:#75715e">// 15（5 + 10）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">add</span>(<span style="color:#ae81ff">2</span>)(<span style="color:#ae81ff">4</span>)); <span style="color:#75715e">// 6（直接链式调用）
</span></span></span></code></pre></div><h3 id="4-缓存优化记忆函数">4. 缓存优化（记忆函数）</h3>
<p>利用闭包缓存函数执行结果，避免重复计算（适用于计算密集型函数）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 示例：缓存斐波那契数列计算结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fibonacciCache</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">cache</span> <span style="color:#f92672">=</span> {}; <span style="color:#75715e">// 闭包缓存，存储已计算的结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">fib</span>(<span style="color:#a6e22e">n</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">n</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">n</span>]) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">n</span>]; <span style="color:#75715e">// 若已缓存，直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 计算并缓存结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">result</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fib</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">fib</span>(<span style="color:#a6e22e">n</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cache</span>[<span style="color:#a6e22e">n</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">result</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">result</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fib</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fib</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fibonacciCache</span>();
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">fib</span>(<span style="color:#ae81ff">10</span>)); <span style="color:#75715e">// 55（首次计算，缓存 2-10 的结果）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">fib</span>(<span style="color:#ae81ff">15</span>)); <span style="color:#75715e">// 610（复用缓存的 2-10 结果，仅计算 11-15）
</span></span></span></code></pre></div><h3 id="5-模块化开发iife-模式">5. 模块化开发（IIFE 模式）</h3>
<p>早期 JavaScript 无模块化机制时，通过 IIFE（立即执行函数表达式）创建闭包，实现模块隔离。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 示例：创建一个工具模块，仅暴露指定方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">MathUtils</span> <span style="color:#f92672">=</span> (<span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 私有变量：模块内部使用，外部无法访问
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">PI</span> <span style="color:#f92672">=</span> Math.<span style="color:#a6e22e">PI</span>;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 私有方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 暴露公共接口（闭包保留对私有变量/方法的访问）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">circleArea</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">r</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">PI</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">r</span>);
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">cube</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>(<span style="color:#a6e22e">x</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">square</span>(<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>})();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">MathUtils</span>.<span style="color:#a6e22e">circleArea</span>(<span style="color:#ae81ff">2</span>)); <span style="color:#75715e">// 12.566...（PI * 2²）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">MathUtils</span>.<span style="color:#a6e22e">cube</span>(<span style="color:#ae81ff">3</span>)); <span style="color:#75715e">// 27（3 * 3²）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">MathUtils</span>.<span style="color:#a6e22e">PI</span>); <span style="color:#75715e">// undefined（无法访问私有变量）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">MathUtils</span>.<span style="color:#a6e22e">square</span>(<span style="color:#ae81ff">4</span>)); <span style="color:#75715e">// undefined（无法访问私有方法）
</span></span></span></code></pre></div><h2 id="四闭包的使用注意事项">四、闭包的使用注意事项</h2>
<p>为了避免闭包带来的问题，使用时需注意以下几点：</p>
<ol>
<li>
<p><strong>及时释放闭包</strong>：不再使用的闭包，应手动解除引用（如赋值为 <code>null</code>），让垃圾回收机制回收内存；</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">sayHello</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">outerFunc</span>(<span style="color:#e6db74">&#34;闭包&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sayHello</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">sayHello</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>; <span style="color:#75715e">// 解除引用，释放闭包占用的内存
</span></span></span></code></pre></div></li>
<li>
<p><strong>避免过度使用闭包</strong>：非必要场景下不要滥用闭包，尤其是循环中创建闭包时，需注意变量绑定问题（可使用 <code>let</code> 块级作用域替代 IIFE）；</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#75715e">// 现代方案：let 块级作用域替代 IIFE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">setTimeout</span>(<span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">i</span>); <span style="color:#75715e">// 输出：0、1、2（let 每次循环创建独立作用域）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }, <span style="color:#ae81ff">1000</span> <span style="color:#f92672">*</span> (<span style="color:#a6e22e">i</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>避免闭包引用过大的对象</strong>：若闭包引用了外部函数的大型对象（如 DOM 元素），即使函数执行完毕，该对象也无法被回收，可能导致内存泄漏；</p>
</li>
<li>
<p><strong>注意this指向问题</strong>：闭包中的 <code>this</code> 指向需谨慎，若内部函数是普通函数，<code>this</code> 可能指向全局对象（非严格模式）或 <code>undefined</code>（严格模式），可通过箭头函数或 <code>bind</code> 绑定 <code>this</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-js" data-lang="js"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;obj&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">outer</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">self</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>; <span style="color:#75715e">// 保存 this 引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// undefined（普通函数 this 指向全局）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#a6e22e">self</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// obj（通过闭包保留 self 引用）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 箭头函数方案（箭头函数无自身 this，继承外部 this）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">obj2</span> <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;obj2&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">outer</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">function</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> () =&gt; {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span>); <span style="color:#75715e">// obj2（继承 outer 的 this）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
</ol>
<h2 id="五总结">五、总结</h2>
<p>闭包是 JavaScript 基于词法作用域的核心特性，其本质是「函数 + 定义时的词法环境」。它既带来了数据封装、模块化、状态记忆等强大能力，也存在内存占用、调试复杂等潜在问题。</p>
<p>掌握闭包的关键在于理解「作用域链」和「垃圾回收机制」的交互逻辑，在实际开发中需根据场景合理使用：用闭包解决特定问题（如私有变量、缓存、回调上下文），同时避免滥用导致的性能或内存问题。</p>
<p>闭包不仅是前端面试的高频考点，更是写出高质量 JavaScript 代码的基础，深入理解并灵活运用闭包，能显著提升开发者的编程能力和代码设计水平。</p>

        
    </div>

    <div class="prev-next">
        
    </div>

    
    
        <svg id="btt-button" class="arrow-logo" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512" onclick="scrollToTop()" title="Go to top">
    
    <path d="M177 159.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 329.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/>
</svg>
<script>
    let backToTopButton = document.getElementById("btt-button");

    window.onscroll = function() {
        scrollFunction()
    };

    function scrollFunction() {
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
            backToTopButton.style.display = "block";
        } else {
            backToTopButton.style.display = "none";
        }
    }

    function scrollToTop() {
        window.scrollTo(0, 0);
    }
</script>

    
    
</div>



    

        </main><footer class="footer">
    
    

    

    

        
            
        

        

        
        

        

    

    
        <span>&copy; 2025 The Marauders</span>
    

    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/gokarna-theme/gokarna-hugo">Gokarna</a>
    </span>
</footer>
</body>
</html>
